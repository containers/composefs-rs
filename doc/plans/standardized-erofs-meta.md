# Standardized EROFS Metadata Serialization

This document outlines the goal of standardizing how composefs serializes filesystem trees to EROFS metadata images.

## Goal

Standardize how a filesystem tree, expressed canonically as a composefs dumpfile (or equivalent representation), is serialized to EROFS metadata. This enables reproducible EROFS generation across implementations.

## Conceptual Model

The canonical transformation model is:

```
tar layer → dumpfile → EROFS metadata
```

Even when implementations optimize by going directly from tar to EROFS for efficiency, the canonical model remains tar → dumpfile → EROFS. This means:

1. Two implementations processing the same tar layer should produce equivalent dumpfiles
2. Two implementations processing the same dumpfile MUST produce byte-identical EROFS images
3. Therefore, two implementations processing the same tar layer should produce byte-identical EROFS images

The dumpfile serves as the canonical intermediate representation that defines the filesystem tree independent of serialization format.

## Why This Matters

- **Reproducible EROFS generation**: Given identical inputs, composefs-c, composefs-rs, and any future implementations must produce byte-for-byte identical EROFS images
- **fsverity digest interoperability**: The OCI sealing specification relies on fsverity digests of EROFS images. These digests must match across implementations for signatures to verify correctly
- **Ecosystem compatibility**: Container runtimes, build tools, and registries can use different implementations interchangeably

Without standardized EROFS output, a signature created by one implementation would fail verification when the EROFS is regenerated by a different implementation.

## Current State

This standardization is a work in progress:

- **[composefs/composefs#423](https://github.com/composefs/composefs/discussions/423)**: Discussion on compatible EROFS output across implementations
- **[composefs-rs PR #225](https://github.com/containers/composefs-rs/pull/225)**: Initial reimplementation of composefs-c in Rust, with compatible EROFS output as a key goal

## Open Questions

The following details need to be standardized (future work):

### EROFS Format Options
- EROFS format version and feature flags
- Block size (currently 4096)
- Compression settings (composefs uses uncompressed metadata)

### Inode Representation
- Compact vs extended inode format
- Inode numbering scheme
- Handling of hardlinks (inode sharing)

### Metadata Ordering
- Inode table ordering (depth-first? breadth-first? by path?)
- Directory entry ordering within directories
- Xattr key ordering within an inode
- Shared xattr table construction algorithm

### Content Handling
- Inline data threshold (currently ~64 bytes for external, but exact cutoff matters)
- External file references via overlay metacopy xattrs
- Symlink target storage

### OCI-Specific Concerns
- Whiteout representation (should not appear in final EROFS — processed during merge)
- Root inode metadata normalization (copying from `/usr`)
- Timestamp precision (seconds only, matching tar limitations)

## References

- [composefs dumpfile format](../splitstream.md) — related binary format documentation
- [OCI sealing specification](oci-sealing-spec.md) — depends on reproducible EROFS generation
- [EROFS documentation](https://docs.kernel.org/filesystems/erofs.html) — kernel filesystem documentation
